include/reader.h:54:54: performance: Function parameter 'code' should be passed by const reference. [passedByValue]
  line_info(const unsigned lineno, const std::string code) : lineno(lineno), code(code) {}
                                                     ^
src/cli/tan-interpreter.cpp:7:89: performance: Function parameter 'delimiter' should be passed by const reference. [passedByValue]
static std::vector<std::string> flag_to_list(const std::string &flag, const std::string delimiter = ",") {
                                                                                        ^
src/cli/tanc.cpp:7:89: performance: Function parameter 'delimiter' should be passed by const reference. [passedByValue]
static std::vector<std::string> flag_to_list(const std::string &flag, const std::string delimiter = ",") {
                                                                                        ^
src/compiler/compiler_session.cpp:14:3: performance: Variable '_context' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
  _context = std::make_unique<LLVMContext>();
  ^
src/compiler/compiler_session.cpp:21:3: performance: Variable '_context' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
  _context = std::make_unique<LLVMContext>();
  ^
src/compiler/compiler_session.cpp:35:3: performance: Variable '_context' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
  _context = nullptr;
  ^
src/compiler/compiler_session.cpp:36:3: performance: Variable '_builder' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
  _builder = std::move(builder);
  ^
src/compiler/interpreter.cpp:71:10: warning: Identical condition and return expression 'e', return value is always 0 [identicalConditionAfterEarlyExit]
  return e;
         ^
src/compiler/interpreter.cpp:62:7: note: If condition 'e' is true, the function will return/exit
  if (e) { throw std::runtime_error("Interpreter evaluation failed"); }
      ^
src/compiler/interpreter.cpp:71:10: note: Returning identical expression 'e'
  return e;
         ^
src/lexer/lexer.cpp:136:7: style: Statements following return, break, continue, goto or throw will never be executed. [unreachableCode]
      delete t;
      ^
src/lexer/lexer.cpp:161:5: style: Statements following return, break, continue, goto or throw will never be executed. [unreachableCode]
    exit(1);
    ^
src/lexer/lexer.cpp:183:5: style: Statements following return, break, continue, goto or throw will never be executed. [unreachableCode]
    exit(1);
    ^
src/lexer/lexer.cpp:267:11: style: Statements following return, break, continue, goto or throw will never be executed. [unreachableCode]
          exit(1);
          ^
src/lexer/lexer.cpp:278:9: style: Statements following return, break, continue, goto or throw will never be executed. [unreachableCode]
        exit(1);
        ^
src/lexer/lexer.cpp:289:9: style: Statements following return, break, continue, goto or throw will never be executed. [unreachableCode]
        exit(1);
        ^
src/lexer/lexer.cpp:300:9: style: Statements following return, break, continue, goto or throw will never be executed. [unreachableCode]
        exit(1);
        ^
src/tanc/tanc.hpp:11:3: performance: Variable '_input_files' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
  _input_files = files;
  ^
src/lib/libtanc.cpp:8:8: style: The scope of the variable 'r' can be reduced. [variableScope]
  bool r;
       ^
src/tanc/tanc.hpp:8:50: performance: Function parameter 'files' should be passed by const reference. [passedByValue]
TanC<PARSER_TYPE>::TanC(std::vector<std::string> files, bool print_ast, bool print_ir_code) {
                                                 ^
src/parser/parser.cpp:12:3: warning: Class 'Parser' does not have a copy constructor which is recommended since it has dynamic memory/resource allocation(s). [noCopyConstructor]
  _compiler_session = new CompilerSession("main");
  ^
src/parser/parser.cpp:12:3: warning: Class 'Parser' does not have a operator= which is recommended since it has dynamic memory/resource allocation(s). [noOperatorEq]
  _compiler_session = new CompilerSession("main");
  ^
src/parser/parser.cpp:183:3: style: Throwing a copy of the caught exception instead of rethrowing the original exception. [exceptRethrowCopy]
  TRY_NUD(node, strict);
  ^
src/parser/parser.cpp:192:3: style: Throwing a copy of the caught exception instead of rethrowing the original exception. [exceptRethrowCopy]
  TRY_NUD(node, strict);
  ^
src/parser/parser.cpp:200:3: style: Throwing a copy of the caught exception instead of rethrowing the original exception. [exceptRethrowCopy]
  TRY_NUD(node, strict);
  ^
src/parser/parser.cpp:188:0: style: The function 'parse < ASTType :: FUNC_CALL >' is never used. [unusedFunction]

^
src/parser/parser.cpp:179:0: style: The function 'parse < ASTType :: ID >' is never used. [unusedFunction]

^
src/parser/parser.cpp:197:0: style: The function 'parse < ASTType :: TY >' is never used. [unusedFunction]

^
examples/read-cmd-args-with-c/print_args.c:4:0: style: The function 'print_args' is never used. [unusedFunction]

^
examples/link-against-c/print_shit.c:4:0: style: The function 'print_shit' is never used. [unusedFunction]

^
src/compiler/compiler_session.cpp:72:0: style: The function 'set' is never used. [unusedFunction]

^
nofile:0:0: information: Cppcheck cannot find all the include files (use --check-config for details) [missingInclude]

